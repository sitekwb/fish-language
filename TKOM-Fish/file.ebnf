Letter = UpperLetter | LowerLetter
UpperLetter = "A" |...| "Z"
LowerLetter = "a" |...| "z"
Zero = "0";
NonZero = "1" |...| "9";
Digit = NonZero | Zero;
Sign = ? ASCII 32-126 ?

Str = "\"", {(Sign - "\\" - "\"") | ("\\", Sign)} "\"" | "'" {Sign} "'"
Bool = "true" | "false"
Int = NonZero, {Digit} | Zero;
Dbl =  Int, [".", Digit, {Digit}];
ConstantValue = Int | Dbl | Str | Bool

Identifier = Letter, {Letter | Digit | "_"};
Type = Identifier;
Constant = "_", UpperLetter, {UpperLetter};
Library = Identifier;

#ANALIZA SK≈ÅADNIOWA

File = {Statement | FunctionDefinition | ClassDefinition};
Statement = (CompoundStatement | SimpleStatement), [";"];

#SIMPLE
SimpleStatement = ExpressionStatement | DeleteStatement | ImportStatement | NewStatement | AssignStatement | ControlStatement | AliasStatement;

ExpressionStatement = Expression;
DeleteStatement = "delete", Identifier;
ImportStatement = "import", Library, ["as", Library];
NewStatement = NewExpression;
AssignStatement = AssignExpression;
ControlStatement = "break" | "continue";
AliasStatement = "alias", Type, Type;

Expression = [(ArithmeticExpression | NewExpression), {',', (ArithmeticExpression | NewExpression)}];

NewExpression = "new", ["mut"], ["static"], [Type], (Identifier | Constant), ['(', ArgumentList, ')'] [AssignOperator, ConditionalExpresion];
AssignExpression = Identifier, AssignOperator, Term;

ConditionalExpression = AndExpression, {"or", AndExpression};
AndExpression = OrExpression, {"and", OrExpression};
OrExpression = [UnaryNot], RelativeExpression, {RelativeOperator, [UnaryNot], RelativeExpression};
RelativeExpression = '(' ConditionalExpression ')' | ArithmeticExpression;

ArithmeticExpression = AddExpression, {AddOperator, AddExpression};
AddExpression = MultiplyExpression, {MultiplyOperator, MultiplyExpression};
MultiplyExpression = [UnarySign], Term;
Term = Int | Dbl | Str | Bool | '(', ArithmeticExpression, ')'
      | ((Identifier | Constant | FunctionCall), {ArraySubscript}), {'.', (Identifier | Constant | FunctionCall), {ArraySubscript}}


FunctionCall = Identifier, '(', ArgumentList, ')';
ArgumentList = [Argument, {',', Argument}];
Argument =  ConditionalExpression;


AssignOperator = '=' | "+=" | "-=" | "*=" | "/=" | "%=";
RelativeOperator = "==" | "!=" | "<" | ">" | "<=" | ">=";
AddOperator = "+" | "-";
MultiplyOperator = "*" | "/" | "%";
UnarySign = "+" | "-";
UnaryNot = "not" | "!";

ArraySubscript = "[", (UnsignedIntTerm | ([UnsignedIntTerm], ':', [UnsignedIntTerm]), "]";
UnsignedIntTerm = Term;


#COMPOUND
CompoundStatement = IfStatement | WhileStatement | ForStatement | ForiStatement | ForeachStatement | FunctionDefinition | ClassDefinition;
BlockInstruction = ("{", {Statement}, "}") | Statement;

IfStatement = "if", '(', ConditionalExpression, ')', BlockInstruction, ["else", BlockInstruction];
WhileStatement = "while", '(', ConditionalExpression, ')', BlockInstruction;
ForStatement = "for", '(', Expression, ';', ConditionalExpression, ';' Expression, ')', BlockInstruction;
ForiStatement = "fori", '(', UnsignedIntTerm, ')', BlockInstruction;
ForeachStatement = "foreach", '(', Identifier, "in", ListIdentifier, ')', BlockInstruction;
FunctionDefinition = "def", [Type], Identifier, '(', ParameterList, ')', BlockInstruction;
ClassDefinition = "class", Type, '{', ClassBody, '}';

ParameterList = [Parameter, {',', Parameter}];
Parameter = [Type], Identifier, ['=', Default];
Default = Term;

ListIdentifier = Identifier, [ArraySubscript];

ClassBody = {ClassBodyStatement};
ClassBodyStatement = (MemberDefinition | FunctionDefinition), Newline;
MemberDefinition = ["public" | "private" | "secret"], ["mut"], ["static"], [Type], Identifier, ['(', ArgumentList, ')'];